# Never ever implement (low-level) networking on your own... seriously

## Define Message

Notes
* Language neutral
* Platform neutral
* extensible mechanism for serializing structured data
* Think XML or Json but smaller faster and simpler
* Protocol buffers are define in proto files with a java similar syntax

Implementation Details
* question message has an id, the name of the person that asks the question and the question text.
* answer contains the same id as the question as reference and the answer text


```Protocol Buffer
syntax = "proto3";

package at.jku.isse.psma.tutorial.grpc;

option java_package = "at.jku.isse.psma.tutorial.grpc";
option java_outer_classname = "ClassroomProtos";
option java_multiple_files = true;

// ---- Messages ----

message Question {
    string id = 1;
    string name = 2;
    string text = 3;
}

message Answer {
    string id = 1;
    string text = 2;
}
```
**2 BULLET POINTS**
## Define Service

* gRPC service are define within the proto file
* SimpleQuestions -> **Point to Point**
* MultipleSimpleQuestions -> **Stream to Point**
* ComplexQuestion -> **Point to Stream**
* MultipleComplexQuestions -> **Stream to Stream**

```Protocol Buffer
...

// ---- Services ----

service ProfessorService {
    rpc askSimpleQuestion (Question) returns (Answer) {
    }

    rpc askMultipleSimpleQuestions (stream Question) returns (Answer) {
    }

    rpc askComplexQuestion (Question) returns (stream Answer) {
    }

    rpc askMultipleComplexQuestions (stream Question) returns (stream Answer) {
    }
}

// ---- Messages ----

...
```
**BULLET POINT**
## Classroom server implementation

* Server receives the port on which he listens and the services... in this case th eprocessor
* The server itself will be registered as shutdown hook such that everything is closed if the JVM stops
* Server starts a new process in the background hence the executing process won't be blocked

```Kotlin
class Classroom(private val port: Int,
                service: ProfessorService) {
    companion object {
        private val logger = LoggerFactory.getLogger(Classroom::class.java)
    }

    private val server: Server = ServerBuilder.forPort(port)
            .addService(service)
            .build()

    fun start() {
        server.start()
        logger.info("Server started, listening on $port")

        Runtime.getRuntime().addShutdownHook(Thread(Runnable {
            logger.error("shutting down gRpc server since JVM is shutting down")
            stop()
            logger.error("server shut down")
        }))
    }

    fun stop() {
        server.shutdown()
    }

    fun blockUnitShutdown() {
        server.awaitTermination()
    }
}
```
**BULLET POINT**
## Generate Java Messages and Services

* protobuf gradle plugin downloads the protoc compiler
* it feeds the proto files as input and the compiler produces the message files and services

```Gradle
plugins {
    id 'org.jetbrains.kotlin.jvm' version '1.1.3'
    id 'com.google.protobuf' version '0.8.1'
}

repositories {
    mavenCentral()
}

dependencies {
    // Networking
    compile group: 'io.grpc', name: 'grpc-all', version: version_grpc
...
}

// ---- Source Sets ----

sourceSets {
    main {
        java {
            srcDir "${buildDir}/generated/source/proto/main/java"
            srcDir "${buildDir}/generated/source/proto/main/grpc"
        }
    }
}

// ---- Protocol Buffer & gRpc ----

protobuf {
    protoc {
        artifact = "com.google.protobuf:protoc:$version_protoc"
    }
    plugins {
        grpc {
            artifact = "io.grpc:protoc-gen-grpc-java:${version_grpc}"
        }
    }
    generateProtoTasks {
        ofSourceSet('main')*.plugins {
            grpc {}
        }
    }
}

compileKotlin.dependsOn 'generateProto'

...
```
**BULLET POINT**
## Professor Answering

Note
* `ProfessorServiceGrpc.ProfessorServiceImplBase()` is generated by the proto compiler

Implementation Details
* Maps questions "fuzzy" onto answers
* Goes through key and checks whether they are contained in the question and returns all matching key values.

```Kotlin

class ProfessorService(val name: String) : ProfessorServiceGrpc.ProfessorServiceImplBase() {

    companion object {
        private val logger = LoggerFactory.getLogger(ProfessorService::class.java)
    }

    private val knowledge: Map<String, String> = mapOf(
            Pair("your name", "My name is $name."),
            Pair("age", "I am 45 years old."),
            Pair("mde", "MDE means model driven engineering."),
            Pair("my mark", "An A but don't get ahead of yourself."),
            Pair("next topic", "We will learn about gRpc."))
            .withDefault { "I cannot help you with that." }

    private fun findAnswers(question: String): List<String> {
        val answer = knowledge.entries
                .filter { (key, _) -> question.toLowerCase().contains(key) }
                .map { it.value }

        return if (answer.isNotEmpty()) answer else listOf("I cannot help you with that.")
    }

 //...
}

```

## Professor communication mode - generated methods

* Point input is provided as parameter, output is always provided as stream
* Output is **pushed** onto the response observer as in contrast to pulled (normal call flow) because of the async nature
* Input streams are solved by returning a stream on which the other side can **push** their messages


```Kotlin
    override fun askSimpleQuestion(request: Question, responseObserver: StreamObserver<Answer>) 
    
    override fun askMultipleSimpleQuestions(responseObserver: StreamObserver<Answer>): StreamObserver<Question>

    override fun askComplexQuestion(request: Question, responseObserver: StreamObserver<Answer>)
    
    override fun askMultipleComplexQuestions(responseObserver: StreamObserver<Answer>): StreamObserver<Question>
```

## Professor - simpleQuestion

**Get one question provide one answer**
* First we find the answer
* Since it is a simple questions we will only provide a simple answer
* Protocol buffers immutable and created via builders
* Push the answer onto the reponseObserver
* And notify the other side when we are finished

```Kotlin
override fun askSimpleQuestion(request: Question, responseObserver: StreamObserver<Answer>) {
        logger.info("Receiving new question from ${request.name} (${request.id})")

        val answerText = findAnswers(request.text).first()

        val answer = Answer.newBuilder()
                .setId(request.id)
                .setText(answerText)
                .build()

        responseObserver.onNext(answer)

        responseObserver.onCompleted()

        logger.info("Answered question ${request.id}")
    }
```

## Professor - MultipleSimpleQuestions

**Get multiple questions provide one answer**
* We return an anonymous implementation of the question observer
* On error just reports the error
* On next finds the answer and stores it temporarily
* On complete combines the answer into one and returns it

```Kotlin
    override fun askMultipleSimpleQuestions(responseObserver: StreamObserver<Answer>): StreamObserver<Question> {
        logger.info("Receiving multiple questions ... i will provide only one answer.")

        return object : StreamObserver<Question> {
            private var id = ""
            private var answers = mutableListOf<String>()

            override fun onError(t: Throwable) {
                val status = Status.fromThrowable(t)
                logger.error("Something disturbing happened in the classroom. ($status)", t)
            }

            override fun onNext(question: Question) {
                if (id.isEmpty()) id = question.id

                answers.add(findAnswers(question.text).first())
            }

            override fun onCompleted() {
                val answer = Answer.newBuilder()
                        .setId(id)
                        .setText(answers.joinToString(" "))
                        .build()

                responseObserver.onNext(answer)

                responseObserver.onCompleted()

                logger.info("Answered question $id")
            }
        }
    }
```

## Professor - ComplexQuestion

**Get complex question provide multiple answers**
* Pushes each found question

```Kotlin
    override fun askComplexQuestion(request: Question, responseObserver: StreamObserver<Answer>) {
        logger.info("Receiving new question from ${request.name} (${request.id})")

        findAnswers(request.text)
                .forEach {
                    val answer = Answer.newBuilder()
                            .setId(request.id)
                            .setText(it)
                            .build()
                    responseObserver.onNext(answer)
                }

        responseObserver.onCompleted()

        logger.info("Answered question ${request.id}")
    }
```

## Professor - MultipleComplexQuestion

* Joins the answers of one complex question into one answer.
* Pushes each answers

```Kotlin
    override fun askMultipleComplexQuestions(responseObserver: StreamObserver<Answer>): StreamObserver<Question> {
        logger.info("Receiving multiple questions ... i will provide multiple answers.")

        return object : StreamObserver<Question> {
            override fun onError(t: Throwable) {
                val status = Status.fromThrowable(t)
                logger.error("Something disturbing happened in the classroom. ($status)", t)
            }

            override fun onNext(question: Question) {

                val answer = Answer.newBuilder()
                        .setId(question.id)
                        .setText(findAnswers(question.text).joinToString(" "))
                        .build()

                responseObserver.onNext(answer)
            }

            override fun onCompleted() {
                responseObserver.onCompleted()

                logger.info("Answered all questions")
            }
        }
    }
```

## Student -- channel and observer

* The channel manages the networking aspect 
* The stub provides an async implementation of the client (block is also available)
* LoggerStreamObserver just writes the question and answer to the console.

```Java
public class Student {

    private static final Logger logger = LoggerFactory.getLogger(Student.class);

    private final ProfessorServiceGrpc.ProfessorServiceStub asyncProfessor;

    public Student() {
        Channel channel = ManagedChannelBuilder.forAddress("localhost", 50051)
                .usePlaintext(true) // no ssl
                .build();
        asyncProfessor = ProfessorServiceGrpc.newStub(channel);
    }

    private class LoggerStreamObserver implements StreamObserver<Answer> {

        final CountDownLatch finishLath = new CountDownLatch(1);

        @Override
        public void onNext(final Answer value) {
            logger.info("*** [Professor]: {}", value.getText());
        }

        @Override
        public void onError(final Throwable t) {
            logger.error("*** [Storyteller] Something disturbed the classroom.", t);
            finishLath.countDown();
        }

        @Override
        public void onCompleted() {
            logger.info("*** [Java Student]: Thank you professor.");
            finishLath.countDown();
        }
    }
    
    private Question newQuestion(String question) {
        return Question.newBuilder()
                .setId(UUID.randomUUID().toString())
                .setText(question)
                .build();
    }
    //...
}
```

## Student simple question

* We create a protocol buffer question and a logger observer for our answer and provide both to the async prof
* We than need to wait for the answer

```Java
    //...
    
    // Point to Point Communication
    public void askSimpleQuestion(String question) {
        logger.info("*** [Java Student]: {}", question);

        Question questionProto = newQuestion(question);

        LoggerStreamObserver responseObserver = new LoggerStreamObserver();
        asyncProfessor.askSimpleQuestion(questionProto, responseObserver);

        try {
            responseObserver.finishLath.await(1, TimeUnit.MINUTES);
            logger.info("*** [Storyteller]: Finished asking.");
        } catch (InterruptedException e) {
            MDC.put("speaker", "Storyteller");
            logger.warn("*** [Storyteller]: The professor did not answer within 1 minute.");
        }
    }
    //...
```

**Copy remainder of code from the finished version**